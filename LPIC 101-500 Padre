Uname 		- გვიბრუნებს ვერსიას რომელსაც იყენებს ჩვენი მანქანა. Prints the kernel name.
Uname -s	-  გვიბრუნებს ზუსტად იგივე ინფორმაციას რასაც ზედა. Prints the kernel name.
Uname -r 	- იდეაში არის რელიზის ინფორმაცია, თუმცა აბრუნებს, რომელი ვერსია აყენია ჩვენს მანქანაზე. Prints the kernel release.
Uname -v	- გვიჩვენებს როდის დაიბილდა ჩვენი ვერსია, იდეაში გვაქვენებს კერნელის ვერსიას, თუმცა თარიღში დაბილდვის თარიღია მოცემული და არა ვერსიის გამოშვების.     Prints the kernel version.
Uname -a 	- გვიჩვენებს მთელს ინფორმაციას ჩვენს მანქანაზე. print all information, in the following order, except omit -p and -i if unknown.
Bash –version		- გვიჩვენებს ბაშის რომელი ვერსია გვიყენია. Show version information for this instance of bash on the standard output and exit successfully.
Type (command) - გვეუბნება Command-ის ნაცვლად ჩაწერილი ბრძანება ჩაშენებულია ბაშში, თუ შემდგომ ჩვენს მიერ დაინსტალირებული სხვა პაკეტის ნაწილია.
Unalias		 - The unalias command removes the definition for each alias name specified, or removes all alias definitions if the -a flag is used. Alias definitions are removed from the current shell environment.
Man 		- man command in Linux is used to display the user manual of any command that we can run on the terminal. It provides a detailed view of the command which includes NAME, SYNOPSIS, DESCRIPTION, OPTIONS, EXIT STATUS, RETURN VALUES, ERRORS, FILES, VERSIONS, EXAMPLES, AUTHORS and SEE ALSO.
Info		- Command info display information in the document format. It is similar to man command with more robustness for linking pages together. Info pages are made with texinfo tools, can link with other pages and create menus. The info document's default location is /usr/share/info.
Help		- Simply type your command whose usage you to know in the terminal with –h or –help after a space and press enter. And you'll get the complete usage of that command as shown below.
ასევე man, info და help ბრძანებებისთვის შეგვიძლია გამოვიყენოთ man man, info info და help help ბრძანებები, რომლებიც მოგვცემს დამატებით ინფორმაციას ამ კონკრეტულ ბრძანებებზე და დაგვეხმარება მის გამოყენებაში.
History		- გვიჩვენებს ჩვენს მიერ გამოძახებული ბრძანებების ისტორიას.
History -c 	- ასუფთავებს ისტორიას, რომელშიც დამახსოვრებულია ჩვენს მიერ გამოძახებული ბრძანებები.
History -w	- წერს ისტორიის სიაში დამახსოვრებულ ბრძანებებს .bash_history ფაილში, რომელიც მდებარეობს ჩვენი იუზერის Home Directory-ში /etc ფოლდერში.
! (რიცხვი)		- ამ ისტორიაში ბრძანებები რიგის მიხედვით არის გადანომრილი, თუ ჩავწერთ ! და შემდეგ რიცხვს, ამ რიგის ნომერზე მდგარ ბრძანებას შეასრულებს ტერმინალი.
!!		- ასრულებს წინა ბრძანებას.
Cat		- ბეჭდავს ტერმინალში ფაილის შიგთავსს.
Ls -a		- გვიჩვენებს ყველა ფაილს რომელის დასახელებაც იწყება წერტილით, ანუ ყველა ისეთ ფაილს რომელიც დამალულია (hidden files).
Ls -F		- აკეთებს ჩვენს დირექტორიაში ფაილების კლასიფიკაციას და აყოლებს თან შემდეგ ინდიკატორებს (/, *, @). / = Directory, * = executable file, @ = symbolic link.
Ls -l		- აკეთებს ამ დირექტორიაში განთავსებული ფაილების გრძელ ფორმატში ლისტინგს.
Head 		- გვაჩვენებს ფაილის პირველ 10 ხაზს დეფოლტად, თუმცა შეგვიძლია ‘დავანასტროიკოთ’ და რამდენიც გვინდა პირველი იმდენი ხაზი დავაბეჭდინოთ.
Head -n		- ეს მოდიფიკაცია გვაძლევს საშუალებას მივუთითოთ რამდენი ხაზი წამოგვიღოს, ამ ბრძანების მერე ვწერთ რიცხვს. ან შეგვიძლია head -10 დავწეროთ იგივეს გააკეთებ.
Tail		- გავს head ბრძანებას, უბრალოდ ეს პირიქით მუშაობს ბოლოდან 10 ხაზი მოაქვს დეფოლტად.
Tail -f		- გვაძლევს ბოლო 10 ხაზს დიფოლტად და ასევე თუ რამე ახალი ჩაიწერება ჩვენს ფაილში ამასაც გამოგვიტანს ტერმინალში.
More		- არის ფაილის წაკითხვის თული. გვიჩვენებს ფაილს თავიდან და ასევე გვანახებს ფაილის რამდენი პროცენტი გვაქვს ნანახი. სფეისით შეგვიძლია გამოვაჩინოთ ახალი გვერდი დაბლა მიმართული ისრის ღილაკით ახალი ხაზი. როცა ჩავალთ ბოლოში დაგვაბრუნებს ტერმინალში. მორით შეგვიძლია ფაილში მხოლოდ ქვემოთ მოძრაობა ზემოთ ვეღარ ავალთ.
Less		- გავს მორს ამით შეგვიძლია, რომ როგორც მაღლა ასევე დაბლა ვიმოძრაოთ, ასევე შეგვიძლია ჩვენი ფაილში ადგილმდებარეობის ან ზემოთ ვეძებოთ რაიმე სტრინგი ან ქვემოთ ამისთვის უნდა გამოვიყენოთ - /თუ გვინდა რომ წინ წავიდეს ძებნა, ხოლო ვიყენებთ ? და შემდეგ სტრინგი თუ გვინდა უკან წავიდეს ძებნა.
Wc -l		- ითვლის რამდენი ხაზი არის ფაილში.
Wc -w		- ითვლის რამდენი სიტყვა არის ფაილში.
Wc -c		- ითვლის რამდენი ბაიტი არის ფაილში.
Uniq		- გვაჩვენებს ფაილში მხოლოდ უნიკალურ ხაზებს, თუმცა საქმე იმაშია, რომ ეს ბრძანება აღიქვამს ხაზებს დუბლიკატებად, თუ ისინი ერთმანეთის მიმდევრობით არის ჩაწერილი და ამავდროულად ზუსტად იდენტურია, მაგალითად თუ გვაქვს ფაილი, რომელსაც ჰქვია input.txt აქვს მსგავსი შიგთავსი:
 
და გავუშვებთ ბრძანებას:
Uniq input.txt
დაგვიბრუნდება შემდეგნაირი აუთფუთი.
 
Uniq -c		- დაბეჭდავს თითოეულ ხაზს მიმდევრობით და გვეტყვის რამდენჯერ განმეორდა ის ზედიზედ.
Uniq -d		- მხოლოდ გამოაქვს ისეთი ხაზები, რომლებიც დადუბლირდა (გამოაქვს ერთი ინსტანსი მარტო).
Uniq -D		- გამოაქვს ისეთი ხაზები, რომლებიც დადუბლირდა (გამოაქვს ყველა ინსტანსი).
Nl		- გადანომრავს ხაზებს ფაილში. (არ გადანომრავს ხაზებს, რომლებიც ცარიელია).
Md5sum -	 აგენერირებს ჰაშ კოდს ფაილისთვის. In Linux, the md5sum command is used to calculate and display the MD5 hash (checksum) of a file. The MD5 hash is a 128-bit cryptographic hash function that produces a unique fingerprint for a given file.
Sha256sum -		აგენერირებს ჰაშ კოდს ფაილისთვის.  In Linux, the sha256sum command is used to calculate and display the SHA-256 hash (checksum) of a file. SHA-256 is a widely used cryptographic hash function that generates a unique, 256-bit hash value for a given file.
Sha512sum -		აგენერირებს ჰაშ კოდს ფაილისთვის.  In Linux, the sha512sum command is used to calculate and display the SHA-512 hash (checksum) of a file. SHA-256 is a widely used cryptographic hash function that generates a unique, 512-bit hash value for a given file.
Sort 		- ალაგებს ფაილში მონაცემებს ალფავიტის მიხედვით.
Sort -n		- ალაგებს ფაილში მონაცემებს რიცხვითი მონაცემების მიხედვით.
Paste 		- აწებებს ორ ფაილს ერთად,  მონაცემებს ადგავს ერთმანეთს გვერდიგვერდ. თუ მაგალითად ორ ფაილს ავიღებთ, რომელშიც თითოეულში არის 5 მონაცემი, ოუთფუთშიც 5 ხაზი იქნება, რომელთა შორისაც თითოეულში იქნება ორი მონაცემი, ერთი პირველი ფაილიდან მეორე  - მეორედან. რომელი ფაილის მონაცემი იქნება პირველი განსაზღვრავს ფეისთ ბრძანების შემდეგ რომელი ფაილის სახელს დაწერ პირველს. 
სინტქსის მაგალითი : paste text.txt numbers.txt
Split		- ყოფს მითითებულ ფაილს ბევრ ნაწილად, დიფოლტად მინიჭებული აქვს, რომ დაყოს ფაილები 1000 ხაზიან დოკუმენტებად (1500 ხაზიან დოკუმენტს ორად გაყოფს 1000 და 500), დაგენერირებულ ფაილებს აგდებს იმ დირექტორიაში, რომელზეც ვდგავართ და არქმევს სახელებს დიფოლტად აღებული პრეფიქსი არის X, არქმევს სახელებს შემდეგი პრინციპით, თუ ვთქვათ დააგენერირა 3 ფაილი დაარქმევს მათ სახელებს XAA, XAB, XAC. შეგვიძლია პრეფიქსის შეცვლა. და ასევე შეგვიძლია შევცვალოთ დაყოფის ინტერვალი (რამდენი ხაზი გაიტანოს ცალკე ფაილად).
Split -l		- უთითებს რამდენი ხაზი მონაცემი იყოს თითოეულ ფაილში.
Split (Filename) NewFile		- NewFile-ნაცვალ თუ შევიყვანთ რაიმე სტრინგს ეს სტრინგი გახდება შექმნილი ფაილის სახელებში სუფიქსი, ანუ თუ ვთქვათ შევიყვანეთ არგუმენტად სტრინგი „NewFile“ დაგენერირებული სახელები იქნება NewFileAA, NewFileAB, NewFileAC და ასე შემდეგ.
Cut 		- არის ბრძანება, რომელიც გამოიყენება იმისთვის, რომ დავყოთ ფაილის ინფორმაცია გარკვეულ სექციებად და ამოვიღოთ ჩვენთვის სასურველი მონაცემები ამ დაყოფის შედეგად. მაგალითად ავიღოთ ერთი რენდომ ხაზი /etc/passwd ფაილიდან:
unbound:x:991:986:Unbound DNS resolver:/etc/unbound:/sbin/nologin
ამ ჩანაწერს თუ დავუკვირდებით, ის დაყოფილი სექციებად, რომლებშიც გარკვეული ტიპის ინფორმაცია წერია. ეს ფაილი გამყოფად ანუ Delimiter-ად იყენებს ორ წერტილს „ : „. თუ ჩვენ მივუთითებთ.
    cut -d :  
ამ არგუმენტს ბრძნებას ვეტყვით რომ მონაცემები გამოყოს სექციებად, ანუ ინფორმაციებად, რომლებიც მოქცეულია ამ character-ებს შორის. ხოლო, თუ დავწერთ
Cut -d -f1 /etc/passwd
მოგვცემს ამ დაყოფილი მონაცემების პირველ სექციას. F-ს შემდეგ რა რიცხვსაც ჩავუწერთ იმ სექციის მონაცემს დაგვიბრუნებს. ამ ბრძანებას თუ გავუშვებდით დაგვიწერდა unbound.
Cut -d -f2 /etc/passwd
ამას თუ გავუშვებდით დაგივწერდა X. და ასე შემდეგ. (ეს ბოლოში ახსენა არ ვიცი ამდენად მნიშვნელოვანი თუ იყო ამდენი რო ვწერე)
Tr [the search symbol]  [the replacement symbol]		- ეძებს მითითებულ სიმბოლოს ფაილში და ცვლის მეორე მითითებული სიმბოლოთი. არ ცვლის ორიგინალ ფაილს. 
Od		- In Linux, the od command (octal dump) is used to display the contents of a file or input in various formats, including octal, hexadecimal, or ASCII representation. It is commonly used to examine binary files or to interpret the raw data of a file.
Grep		- ეძებს მითითებულ სტრინგს ფაილში აჰაილაითებს სიტყვას, რომელსაც ვეძებდით და გამოაქვს მთელი სტრიქონი ფაილიდან.
Grep –color=(ColorName)		- გამოიტანს საძიებო მონაცემებს იგივე ლოგიკით, უბრალოდ ჩვენთვის სასურველი ფერით ColorName-ის ნაცვლად თუ გავუწერთ Never-ს არ გააფერადებს საერთოდ მოძიებულ სტრინგს და უბრალოდ გამოიტანს სტრიქონს, რომელშიც ის მოიძებნა.
Grep -i		- ძიებას ხდის Case insensitive-ს. (არ მიაქცევს ყურადღებას დიდ და პატარა ასოებს) დიფოლტად ლინუქსი ქეის სენსიტივია.
Grep ^’SearchWord’		- თუ ახარისხების ნიშანს დავუწერთ საძიებო სტრინგს წინ, მოგივძებნის ისეთ სტრიქონებს, რომლებიც ამ სტრინგით იწყება.
Grep ’SearchWord’$		- საძიებო სტრინგი და დოლარის ნიშანი ბოლოს მოგვიძებნის ისეთ სტრიქონებს, რომლებიც ამ სტრინგით მთავრდება. წინ თუ დავუწერთ დოლარის ნიშანს ცვლადის სახელი ეგონება და არ იმუშავებს.

Text Redirection

Input Redirection		- ლინუქსში შეგვიძლია, რომ ერთი ბრძანების მიერ გამოტანილი აუთფუთი გადავცეთ მეორე ბრძანებას როგორც ინფუთი. ამისთვის ვიყენებთ გადამისამართების ოპერატორებს. მაგალითად, ავიღოთ ბრძანება tr რომელიც ეძებს გარკვეულ სიმბოლოს ტექსტში და ამ სიმბოლოს შემდეგ ანაცვლებს ჩვენს მიერ მითითებული სიმბოლოთი. ის ასე მუშოაბს.
TR : $ < /etc/passwd
ეს ბრძანება აიღებს /etc/passwd ფაილის შიგთავს და გადასცემს tr ბრძანებას ინფუთად, შემდეგ ეს ბრძნება მოძებნის მითითებულ ტექსტში ორ წერტილს ჩაანაცვლებს დოლარის ნიშნით, შედეგს გამოიტანს ტერმინალში და დაბეჭდავს და ამავდროულად არ შეცვლის /etc/passwd ფაილს. 
Output Redirection		- იმ შემთხვევაში თუ ჩვენ გვინდა, რომ ბრძანების აუთფუთი გადავიტანოთ რაიმე ფაილში ამისთვის ვიყენებთ Output Redirection-ს. მაგალითად, გვაქვს ფაილი, რომელშიც არის თითო სტრიქონზე ერთი სიტყვა. ჩვენ შეგვიძლია გამოვიყენოთ sort ბრძანება, ის დაალაგებს ანბანის მიხედვით ფაილს და დაბეჭდავს ტერმინალში, თუმცა არ შეცვლის ორიგინალ ფაილს. თუ ჩვენ გვინდა, რომ ამ ბრძანების შედეგი სადმე ჩავწეროთ ასე მოვიქცევით.
Sort myFile > newFile.txt
ჩაწერს sort ბრძანების აუთფუთს newFile.txt-ში, თუ ფაილი ასეთი დასახელებით არსებობს გადააწერს მის შიგთავსს ახალ აუთფუთს, თუ არ არსებობს შექმნის ახალს.
Sort myFile >> newFile.txt
დატოვებს ფაილის შიგთავს და ბოლოს მიამატებს სორტ ბრძანების აუთფუთს.
Tee		- ეს ბრძანება წაიკითხავს standard input-ს და გამოიტანს, როგორც standard output-ს და ჩაწერ მითითებულ ფაილში (გამოიყენება command pipeline-ებში).

Command pipes: Using pipes for chaining and redirection
 
Command Pipes	- Command Pipes არის ერთგვარი მილსადენი ბრძანებებისთვის, რომელშიც გაედინება ინფორმაცია, კონკრეტულად კი ბრძანებების გამოძახების შედეგად დაბრუნებული აუთფუთი, რომელიც გადაეცემა მის შემდგომ მდგარ ბრძანებას როგორც ინფუთი. ბრძანებები ერთმანეთისგან გამოიყოფა | ოეპრატორით (ზოგ ენაში ‘ან’ ოეპრატორი). მაგალითად:
grep nologin /etc/passwd | tee newFile.txt | sort
ამ შემთხვევაში ჩვენ ვიყენებთ grep ბრძანებას ვეძებთ „nologin“ სტრინგს  /etc/passwd ფაილში. ტერმინალი დააგენერირებს აუთფუთს, სადაც გამოჩნდება შესაბამისი ინფორმაცია, Command Pipeline-ში შემდეგი ბრძანება არის tee, რომელსაც გადაეცემა grep ბრძანების აუთფუთი, ის ამ აუთფუთს ჩაწერს newFile.txt ფაილში და ამასთანავე გადასცემს ამ ინფუთს (tee-სთვის ეს ინფორმაცია ინფუთია, grep-სთვის აუთფუთი) sort ბრძანებას, რომელიც დაალაგებს მას ალფავიტის მიხედვით და გამოიტანს ტერმინალში. (ეს მონაცემები არასორტირებული ჩაიწერება ფაილში, ხოლო სორტირებული დაიბეჭდება ტერმინალში)

Redirecting standard error
Standard error redirection მუშაობს თითქმის იგივენაირად, როგორც სტანდარტული აუთფუთის გადამისამართება, ერთადერთი განსხვავება ის არის რომ გადამისამართების ოპერატორის წინ უნდა დავწეროთ 2-იანი. მაგალითად:
$ Ls /etc/passWords 2> error.txt
იმ შემთხვევაში თუ ფაილი სახელად passWords არ არსებობს ეს ბრძანება დააბრუნებს Error მესიჯს 2-იანი მიუთითებს რომ აუთფუთი, რომლის გადამისამართებასაც ვცდილობთ არის შეცდომის მანიშნებელი მესიჯი, თუ არსებობს ფაილი error.txt გადააწერს მას მესიჯს თავზე, თუ არ არსებობს შექმნის ფაილს ამ დასახელებით.
Ls /etc/ passWords 2>> error.txt
თავზე გადაწერის გარეშე მიამატებს ფაილის ჩანაწერს ბრძანების მიერ დაბრუნებულ შეცდომის მესიჯს.
/dev/null		- ამას ეძახიან ლინუქსის შავ ხვრელს. შეგვიძლია ერორ მესიჯები აქ გადავამისამართოთ. აქ რასაც ჩავყრით ეგრევე დაიკარგება და წაიშლება. (აქედან უკან მობრუნებული არ ახსოვთ ჯერ არაფერი.
Xargs		- ეს ფუნქცია იღებს ინფუთს ბრძანებების პაიპისგან ან redirection operator-ისგან და გვაძლევს საშუალებას, რომ დავაშენოთ ახალი ბრძანება Xargs-ს შემდეგ დავწერთ იმ ბრძანებას, რომელიც  გვინდა რომ ჩვენ ინფუთზე შევასრულოთ, მაგალითად:
Command1 | xargs [options] [command2]
პირველ ბრძანების ინფუთს აიღებს და ჩატენის მეორე ბრძანებაში და შეასრულებს მას.
$(command)		- თუ რაიმე ბრძანებას დავუწერთ წინ დოლარის ნიშანს და ჩავსვამთ ფრჩხილებში, ლინუქსი მას აღიქვამს როგორც ცვლადს და ფრჩხილებში მოქცეულ ბრძანებას შეასრულებს როგორც ქვებრძნანებას და ფუნქციას გადასცემს მის აუთფუთს სხვა ფუნქციას არგუმენტად ან ინფუთად.
grep $(cat newFile.txt) /etc/passwd
ფრჩხილებში მოქცეული ბრძანების აუთფუთი გადაეცემა grep command-ს საძიებო მნიშვნელობად. შეგვიძლია ეს დოლარის ნიშანი და ფრჩხილები მოვაქციოთ ბრჭყალებში იგივენაირად იმუშავებს.
`command`		- იგივენაირად მუშაობს ზუსტად როგორც $(command), თუმცა ერთ სიმბოლოიან ბრჭყალს გავს და აღარ იყენებენ ადმინებიო.
Search operators
[search value]		- grep command-ის გამოყენებით ჩვენ შეგვიძლია საძიებო სტრინგში ერთი სიმბოლო ჩავანაცვლოთ სიმბოლოს რამდენიმე შესაძლო მნიშვნელობით. მაგალითად შეგვიძლია მოვძებნოთ ipv4 და  ipv6 გრეპით შემდეგნაირად.
grep ipv[46] /etc/*
ასევე შეგვიძლია მივუთითოთ რეინჯი და არა სავარაუდო მნიშვნელობები, მაგალითად:
Grep rfc[1-3] etc/*
აქ მოგვცემს რეინჯს სიმბოოებისას რომელსაც მიადგავს ჩვენს საძიებო სტრინგს (1, 2, 3), ანუ გვექნება სამი შესაძლო მნიშვნელობა, რომელსაც გამოიტანს პროგრამა აუთფუთად rfc1, rfc2, rfc3.
Special characters		- თუ ჩვენ გვინდა, რომ მაგალიტად /etc/services ფაილში მოვძებნოთ სტრინგი „# bootp”, თუ ჩვენ გამოვიძახებთ ბრძანებას:
Grep -i # bootp /etc/services
ბრძანება ვერ იმუშავებს, იმიტომ რომ #-ც და სფეისიც, რომელიც მის შემდეგ მოდის სპეციალური სიმბოლოები ლინუქსისთვის. იმისთვის, რომ ამ  ბრძანებამ იმუშაოს ორივეს წინ უნდა დავუწეროთ \.
Grep -i \#\ bootp /etc/services
ასე იმუშავებს ბრძანება.
საძიებო სტრინგში .-ის გამოყენება		- საძიებო სტრინგში შეგვიძლია ასო შევცვალოთ წერტილით, რაც იმას აღნიშნავს, რომ ამ წერტილის მაგივრად ჩაწერილი შეიძლება იყოს მხოლოდ ერთი, მაგრამ ნებისმიერი სიმბოლო. მაგალითად:
Grep ro.t /etc/passwd
წამოიღებს: roit, rout, rost, rokt და ასე შემდეგ.
საძიებო სტრინგში *-ის გამოყენება		- საძიებო სტრინგში შეგვიძლია ასო შევცვალოთ *-ით რაც იმას აღნიშნავს, რომ ამ ფიფქის ნაცვლად შეიძლება ეწეროს ნებისმიერი რაოდენობის და ნებისმიერი სიმბოლო.
Grep ro*t /etc/passwd
წამოიღებს, იმ ყველაფერს, რაც ზედამ წამოიღო ასევე: rot, rodsdsdsdst, rosdft და ასე შემდეგ. არ სფეისებიც კიდია და ყველაფერი ro, რომ ხაზის ტავში იყოს და t ბოლოში მაინც წამოიღებს.
+ operator		- ძიების დროს ეძებს მის წინ ჩაწერილი სიმბოლოს ერთ ან მეტ განმეორებას. ვთქვათ, გვაქვს ასეთი ბრძანება:
Grep str+ /etc/passwd
ეს წამოგვიღებს strr, strrrr და ასე შემდეგ.
? operator		- ძიების დროს ეძებს მის წინ ჩაწერილი სიმბოლოს არცერთ ან ერთ განმეორებას.
Patter1|pattern2		- ეს ოპერატორი აირჩევს მონაცემებს, რომლებიც ერგება ორიდან რომელიმე ფორმატს, დაახლებით იგივეა რაც ან ოპერატორი. თუმცა უნდა გავითვალისწინოთ, რომ ‘|’ special characher-ია. ან \ უნდა დავუწეროთ წინ ან უნდა ჩავსვათ ბრჭყალებში მთელი expression.
Egrep		- არის Grep ბრძანების ძველი ვარიანტი, მათ შორის განსხვავება კი ისაა, რომ მასში ჩაშენებულია Grep ბრძანების -E არგუმენტი, ანუ ის ბუნებრივად მოიაზრებს თავის თავში Extended Regular Expressions. (გამოცდის კითხვა არისო).
Grep -F -f (filename)		- შეგვიძლია პატერნები, რომლებსაც ვუთითებდით არგუმენტად ჩავწეროთ ფაილში და თვითონ ფაილი მივცეთ ფუნქციას არგუმენტად, მაგალითად.
Echo “root” > pattern.txt
Echo “shutdown” >> pattern.txt
Grep -F -f pattern.txt /etc/passwd
იმუშავებს იგივენაირად




























